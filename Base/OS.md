## 操作系统



### 一、概念

 主要功能：控制、资源分配

#### 1. OS将物理资源虚拟化

```shell
CPU -> 进程 、 磁盘 -> 文件 、内存 -> 地址空间
```

**OS包括面向应用程序的shell，面向内部的kernel**

#### 2. 硬件资源管理

* CPU：CPU调度，进程线程管理
* 内存：物理内存与虚拟内存的管理
* 磁盘：文件系统管理
* 中断处理与设备驱动
* ...

#### 3. OS kernel 的特征

* **并发**：一段时间内有多个程序运行

  * 并行：一个时间点上有多个程序同时运行（要求有多个CPU）

  计算机中同时存在多个运行的程序，需要OS管理和调度

* **共享**：“同时”访问、互斥共享

* **虚拟**：将硬件虚拟化

* **异步**：程序走走停停，想起推进的速度不可知，但最终运行的结果相同



### 操作系统的启动

1. BIOS：开机直接检查各硬件是否正常

2. BIOS从硬盘的第一个扇区(512字节)加载 Bootloader
3. BootLoader将操作系统从硬盘加载到内存，并跳转到OS的起始地址
4. 至此计算机的所有资源交由OS管理



### 二、OS与外设、应用程序交互

* 面向外设：中断、IO
* 面向程序：系统调用、异常

| 名称     | 来源 |                    处理时间                    | 响应                           | 描述                                                         |
| -------- | ---- | :--------------------------------------------: | ------------------------------ | ------------------------------------------------------------ |
| 系统调用 | 程序 | 同步或异步（发出请求是同步的，返回点可能异步） | 等待和持续                     | 应用程序主动向OS发出服务请求                                 |
| 异常     | 程序 |           同步（除0一定会产生异常）            | 对程序造成影响                 | 非法指令或其他坏的处理状态，不得不要求操作系统来完成相应功能（例如某程序想要获取其他程序的信息，需要操作系统来处理） |
| 中断     | 外设 |             异步（不知道何时产生）             | 持续，由OS完成，对应用程序透明 | 来自不同的硬件设备的计时器和网络的中断                       |



#### 1. 中断

中断产生时的处理过程：

* 硬件

  外设设置中断标记 -> CPU识别到中断标记生成中断号 -> 将中断号交给OS，OS从中断表(k:v)找到处理程序地址

* 软件（OS）

  保存当前处理状态（保存现场） -> 根据中断号找到对应处理程序进行处理（根据中断的具体情况完成处理）-> 清除中断标记 -> 恢复现场，原程序继续执行  （**应用程序完全感知不到中断**）

#### 2. 异常

异常产生时的处理过程：

应用程序执行指令触发异常事件，cpu受到异常编号 -> OS保存现场 -> OS根据异常编号进行处理(结束异常程序或重新执行异常指令) -> 恢复现场，应用程序重新执行

#### 3. 系统调用

应用程序需要OS提供服务，某些服务不能让应用程序直接执行，必须要OS执行。

例如：print() 触发系统调用，OS访问屏幕输出信息

**Win 32 API 提供Windows系统调用接口 **

**POSIX API 提供Linux、Unix、MacOS系统调用接口**

**Java API 不是系统调用接口**



**应用程序调用系统调用时触发用户态到内核态的转变，控制权由应用程序交到OS**(应用程序发出函数调用时在同一栈空间完成，系统调用时需要切换(堆)栈还有完成用户态到内核态的转换，开销大于函数调用，但是安全)

**用户态**：应用程序执行过程中CPU所处的状态，特权较低，不能直接访问机器指令和IO等

**内核态**：OS运行过程中CPU所处的状态，可以执行任何指令



#### 4. 跨越操作系统边界的开销（应用程序-OS-外设）

开销是值得的，能够保证OS在安全可靠的环境下运行

* 建立中断/异常/系统调用号 对应服务例程映射关系的初始化开销
* OS与应用程序都有自己的堆栈，都需要维护 （建立内核堆栈）
* OS不信任应用程序，需要对系统调用的参数进行检查
* 内核态映射到用户态的地址空间更新
* 内存状态改变 cache TLB刷新



### 三、对物理内存的管理

#### 1. 计算机体系结构&内存分层体系

##### 计算机体系结构

* 硬件结构

  cpu：对程序执行的控制

  内存：放置程序代码和数据

  外设：配合程序

##### 内存分层体系

* cpu访问内存顺序

  ```shell
  cpu -> 寄存器 -> cache  # 位于cpu芯片内部 OS无法直接管理 速度快容量小
  -> 主存(物理内存) # 放置OS本身以及程序代码和数据 速度稍慢
  <-> 虚拟内存(硬盘)
  ```

* OS内存管理工作

  抽象：屏蔽底层硬件，物理内存、外设 抽象为 **逻辑地址空间** 提供给引用程序访问

  保护：控制进程对其他进程地址空间的访问，隔离不同进程的地址空间  **独立地址空间**

  共享：进程间共享内存进行数据交互

  虚拟化：内存不够时，将不常用数据放到硬盘，提供更多地址空间

#### 2. 地址空间 & 地址生成

##### 地址空间

* 物理地址空间：与硬件直接对应，由硬件管理
* 逻辑地址空间：程序能识别的地址空间，一维线性地址空间
* 物理地址和逻辑地址的映射关系由OS管理

##### 逻辑地址空间的生成

* OS 需要完成 物理地址与逻辑地址映射关系的建立

* .c程序(变量) -> .s汇编程序 -> xx.o机器码程序 -> .exe可执行程序 -> 内存中运行（最终逻辑地址生成）

```shell
1. cpu 执行指令时 ALU(计算逻辑单元) 需要指令的内容，发送请求带有逻辑地址
2. MMU(内存管理单元) 查询 逻辑地址与物理地址映射表 找到该逻辑地址对应的物理地址
3. 控制器 向主存发出请求加载物理地址内容
4. 主存拿到内容通过总线传给cpu
```

##### 地址安全检查

* OS要保证内存中的程序不相互干扰，要确保每个程序访问的地址空间是合法的
* 程序合法地址空间范围：起始地址 和 地址长度，超出区域的访问是非法的，该范围表由OS建立

#### 3. 连续内存分配

程序从硬盘加载到内存需要分配内存空间、程序运行时需要访问数据，要给数据分配内存空间 都由OS完成；

分配的内存是连续的，OS需要管理空闲和非空闲的内存空间

##### 内存碎片

* 空闲内存不能被利用
* 外部碎片：为多个应用程序分配的单元之间的未使用内存
* 内部碎片：在程序的内存单元之内未使用的内存

##### 分区的动态分配

OS内存管理算法

##### 压缩式碎片整理

##### 交换式碎片整理