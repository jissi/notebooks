## 操作系统

## 一、概念

 主要功能：控制、资源分配

### 1. OS将物理资源虚拟化

```shell
CPU -> 进程 、 磁盘 -> 文件 、内存 -> 地址空间
```

**OS包括面向应用程序的shell，面向内部的kernel**

### 2. 硬件资源管理

* CPU：CPU调度，进程线程管理
* 内存：物理内存与虚拟内存的管理
* 磁盘：文件系统管理
* 中断处理与设备驱动
* ...

### 3. OS kernel 的特征

* **并发**：一段时间内有多个程序运行

  * 并行：一个时间点上有多个程序同时运行（要求有多个CPU）

  计算机中同时存在多个运行的程序，需要OS管理和调度

* **共享**：“同时”访问、互斥共享

* **虚拟**：将硬件虚拟化

* **异步**：程序走走停停，想起推进的速度不可知，但最终运行的结果相同



### 4. 操作系统的启动

1. BIOS：开机直接检查各硬件是否正常

2. BIOS从硬盘的第一个扇区(512字节)加载 Bootloader
3. BootLoader将操作系统从硬盘加载到内存，并跳转到OS的起始地址
4. 至此计算机的所有资源交由OS管理



## 二、OS与外设、应用程序交互

* 面向外设：中断、IO
* 面向程序：系统调用、异常

| 名称     | 来源 |                    处理时间                    | 响应                           | 描述                                                         |
| -------- | ---- | :--------------------------------------------: | ------------------------------ | ------------------------------------------------------------ |
| 系统调用 | 程序 | 同步或异步（发出请求是同步的，返回点可能异步） | 等待和持续                     | 应用程序主动向OS发出服务请求                                 |
| 异常     | 程序 |           同步（除0一定会产生异常）            | 对程序造成影响                 | 非法指令或其他坏的处理状态，不得不要求操作系统来完成相应功能（例如某程序想要获取其他程序的信息，需要操作系统来处理） |
| 中断     | 外设 |             异步（不知道何时产生）             | 持续，由OS完成，对应用程序透明 | 来自不同的硬件设备的计时器和网络的中断                       |



### 1. 中断

中断产生时的处理过程：

* 硬件

  外设设置中断标记 -> CPU识别到中断标记生成中断号 -> 将中断号交给OS，OS从中断表(k:v)找到处理程序地址

* 软件（OS）

  保存当前处理状态（保存现场） -> 根据中断号找到对应处理程序进行处理（根据中断的具体情况完成处理）-> 清除中断标记 -> 恢复现场，原程序继续执行  （**应用程序完全感知不到中断**）

### 2. 异常

异常产生时的处理过程：

应用程序执行指令触发异常事件，cpu受到异常编号 -> OS保存现场 -> OS根据异常编号进行处理(结束异常程序或重新执行异常指令) -> 恢复现场，应用程序重新执行

### 3. 系统调用

应用程序需要OS提供服务，某些服务不能让应用程序直接执行，必须要OS执行。

例如：print() 触发系统调用，OS访问屏幕输出信息

**Win 32 API 提供Windows系统调用接口 **

**POSIX API 提供Linux、Unix、MacOS系统调用接口**

**Java API 不是系统调用接口**



**应用程序调用系统调用时触发用户态到内核态的转变，控制权由应用程序交到OS**(应用程序发出函数调用时在同一栈空间完成，系统调用时需要切换(堆)栈还有完成用户态到内核态的转换，开销大于函数调用，但是安全)

**用户态**：应用程序执行过程中CPU所处的状态，特权较低，不能直接访问机器指令和IO等

**内核态**：OS运行过程中CPU所处的状态，可以执行任何指令



### 4. 跨越操作系统边界的开销（应用程序-OS-外设）

开销是值得的，能够保证OS在安全可靠的环境下运行

* 建立中断/异常/系统调用号 对应服务例程映射关系的初始化开销
* OS与应用程序都有自己的堆栈，都需要维护 （建立内核堆栈）
* OS不信任应用程序，需要对系统调用的参数进行检查
* 内核态映射到用户态的地址空间更新
* 内存状态改变 cache TLB刷新



## 三、对物理内存的管理

### 1. 计算机体系结构&内存分层体系

#### 计算机体系结构

* 硬件结构

  cpu：对程序执行的控制

  内存：放置程序代码和数据

  外设：配合程序

#### 内存分层体系

* cpu访问内存顺序

  ```shell
  cpu -> 寄存器 -> cache  # 位于cpu芯片内部 OS无法直接管理 速度快容量小
  -> 主存(物理内存) # 放置OS本身以及程序代码和数据 速度稍慢
  <-> 虚拟内存(硬盘)
  ```

* OS内存管理工作

  抽象：屏蔽底层硬件，物理内存、外设 抽象为 **逻辑地址空间** 提供给引用程序访问

  保护：控制进程对其他进程地址空间的访问，隔离不同进程的地址空间  **独立地址空间**

  共享：进程间共享内存进行数据交互

  虚拟化：内存不够时，将不常用数据放到硬盘，提供更多地址空间

### 2. 地址空间 & 地址生成

#### 地址空间

* 物理地址空间：与硬件直接对应，由硬件管理
* 逻辑地址空间：程序能识别的地址空间，一维线性地址空间
* 物理地址和逻辑地址的映射关系由OS管理

#### 逻辑地址空间的生成

* OS 需要完成 物理地址与逻辑地址映射关系的建立

* .c程序(变量，基于符号的地址空间) -> .s汇编程序 -> xx.o机器码程序 -> .exe可执行程序 -> 内存中运行（最终逻辑地址生成）

```shell
1. cpu 执行指令时 ALU(计算逻辑单元) 需要指令的内容，发送请求带有逻辑地址
2. MMU(内存管理单元) 查询 逻辑地址与物理地址映射表 找到该逻辑地址对应的物理地址
3. 控制器 向主存发出请求加载物理地址内容
4. 主存拿到内容通过总线传给cpu
```

#### 地址安全检查

* OS要保证内存中的程序不相互干扰，要确保每个程序访问的地址空间是合法的
* 程序合法地址空间范围：起始地址 和 地址长度，超出区域的访问是非法的，该范围表由OS建立

#### 3. 连续内存分配

程序从硬盘加载到内存需要分配内存空间、程序运行时需要访问数据，要给数据分配内存空间 都由OS完成；

分配的内存是连续的，OS需要管理空闲和非空闲的内存空间

##### 内存碎片

* 空闲内存不能被利用
* 外部碎片：为多个应用程序分配的单元之间的未使用内存
* 内部碎片：在程序的内存单元之内未使用的内存

##### 分区的动态分配

OS内存管理算法

##### 压缩式碎片整理

调整程序的内存块位置（复制-整理），合并碎片

要考虑的问题：

* 何时拷贝
* 开销

##### 交换式碎片整理

将没有运行的程序占用的内存空间移动到硬盘，让出内存

要考虑的问题：

* 将哪个程序拷贝到硬盘
* 打程序的拷贝消耗更多资源



#### 4. 非连续内存的分配

* 采用非连续内存分配的原因：连续内存分配会带来内\外碎片

管理方法：分段、分页

##### 非连续分配特点

* 优点
  * 程序的物理地址空间是非连续的
  * 更好的内存利用和管理
  * 允许共享代码与数据
  * 至此动态加载和动态链接
* 缺点
  * 如何建立逻辑地址与物理地址的转换
    * 软件实现：开销大
    * 硬件实现：两种方案
      * 分段
      * 分页

##### 分段管理机制：段 <=> 内存块

* 程序的分段地址空间

  栈段、堆段等

  逻辑地址空间连续，物理地址分段，需要映射机制来关联

* 分段寻址方案

  一维的线性逻辑地址可以由两部分组成：**段号 + 段内偏移量**，由二维元组就可以表示内存地址；

  **段表** 存储了段的起始地址和长度限制，建立逻辑地址与物理地址的映射关系，由OS负责设置段表

##### 分页机制（常用）：

* 分页地址空间

  分段机制中段的尺寸可变，而页(页帧)的大小固定不变；

  逻辑页大小与物理页大小相同；

  一般说 页代表逻辑页，帧代表物理页

  * 页帧frame：物理内存的组织和布局方式

    由 页帧号 与 帧内偏移 组成

  * 页page：逻辑地址空间

    由 页号 + 页内偏移 组成；

    页内偏移大小与其对应的物理帧内偏移大小一致

* 页寻址方案

  **页表** 建立 页与页帧的映射关系（页号 <-> 帧号），由OS建立页表



## 四、虚拟内存

起因：主存容量不够

### 1. 早期的覆盖技术与交换技术

#### 覆盖技术（分时使用内存空间）

* 原理：

  > 根据程序执行逻辑将程序划分模块，这些模块执行时间有先后顺序，部分程序常驻内存负责将模块往覆盖区(共享区)调度，某个模块需要执行时将其从硬盘调入共享区覆盖原有内容；

* 划分粒度：程序的(函数)调用逻辑

* 实质：同一程序的代码分时使用内存空间

* 开销问题：

  程序员要精心设计程序的模块，覆盖模块从外存装入内存需要消耗时间



#### 交换技术（早期unix系统提出的方案）

* 原理：

  内存空间不足时将不运行的程序以程序为单位从内存导出到外存（swap out），需要执行时再从外存导入内存（swap in）

* 划分粒度：程序

* 开销：与程序大小和交换频率有关

* 需要考虑的问题：

  * 交换时机，频繁交换开销大
  * 交换区的大小 ，必须足够大
  * 程序从外存换入的位置与换出时的位置不一样，动态地址映射技术

### 2. 虚存技术（虚拟内存管理技术）

覆盖技术需要程序员自己设计模块，交换技术将整个进程地址空间换入换出，处理器开销大

* 目标：像覆盖技术一样不把整个程序放入内存，像交换技术一样将进程在内存与外存间交换从而获得更多空闲内存空间

* 要求：**程序的局部性 ** &&分页/分段机制：

  > 时间局部性：一条指令的一次执行和下次执行、数据的一次访问和下次访问都集中在段时间内
  >
  > 空间局部性：当前指令和其邻近的几条指令、当前访问的数据和邻近的几个数据都集中在较小区域内

  

* 原理：

  > 1. 装入程序时只将当前需要执行的页或段装入内存；
  > 2. 程序执行时如果需要访问的数据不在内存（称为缺页或缺段），由处理器通知操作系统将相应页或段装入内存
  > 3. 操作系将内存中暂时不用的页或段导出到外存，腾出空闲内存


**虚存的基本特征 **

* 更大用户空间
* 部分交换

* 不连续：物理内存空间不连续(分页/分段机制)，虚拟内存不连续(换入换出导致）



## 五、进程管理

### 1. 进程描述

##### 进程定义

(静态的)程序在一个数据集合上的一次动态执行过程称为进程；

可以理解为程序的一个实例

##### 进程的组成

> 一个进程包括：程序代码、程序处理的数据、寄存器（堆、栈）、程序计数器(指向下一指令)、系统资源

##### 程序、进程的联系与区别

>联系
>
>1. 程序是产生进程的基础
>
>2. 程序的每次运行产生不同的进程
>3. 进程是程序功能的体系
>4. 通过多次执行，一个程序可以对应多个进程；通过调用，一个进程可以包括多个程序
>
>---
>
>区别
>
>1. 程序是静态的，进程是动态的；进程由 用户态/核心态
>2. 程序是永久的，进程是暂时的
>3. 程序与进程的组成不同



##### 进程的特点

> 1. 动态性：动态创建、结束
> 2. 并发性：可以被调度并占用处理机
> 3. 独立性：不同进程的工作互不影响（页表保证了进程独立性）
> 4. 制约性：因访问共享资源或进程同步而产生制约



##### 进程的控制结构

描述进程的数据结构：**进程控制块(PCB)**；

> OS为每个进程维护一个PCB，用来保存与该进程有关的各种状态信息；
>
> OS通过PCB来描述进程的基本状况已经运行变化的过程

**PCB是进程存在的唯一标志**

> 进程创建：为该进程生成PCB
>
> 进程终止：回收PCB
>
> 进程管理：通过对PCB的管理来实现

##### PCB包含的信息

>1. 进程标识：进程本身标识、父进程标识、用户标识
>2. 处理机状态信息：进程的运行现场信息
>   * 用户可见寄存器：数据、地址寄存器
>   * 控制和状态寄存器：PC(程序计数器)、PSW(程序状态字)
>   * 栈指针
>
>3. 进程控制信息：对进程的管理控制
>   * 调度和状态信息
>   * 进程间通信信息
>   * 存储管理信息
>   * 进程所用资源信息
>   * 有关数据结构连接信息

PCB的组织方式一般使用链表

### 2. 进程状态

##### 生命周期管理

创建、运行、等待、唤醒、结束

>--进程创建：
>
>> 1. 系统初始化时创建init进程
>> 2. 用户请求创建新进程
>> 3. 正在运行的进程执行了创建进程的系统调用
>
>--进程运行：
>
>> 内核选择一个就绪的进程，让它占用处理机并执行
>
>--进程等待：
>
>> 进程只能阻塞自己
>
>> 请求并等待系统服务，无法马上完成
>>
>> 启动某种操作，无法马上完成
>>
>> 需要的数据没有到达
>
>--进程唤醒
>
>> 进程只能被其他进程或OS唤醒
>
>> 被阻塞进程需要的资源被满足
>>
>> 被阻塞进程等待的事件到达
>>
>> 将该进程的PCB插入到就绪队列
>
>-- 进程结束
>
>> 正常退出、错误退出 ：资源退出
>>
>> 致命错误：被强制退出
>>
>> 被其他进程所结束：被强制退出

##### 状态变化模型

创建状态、就绪状态、运行状态、等待状态(阻塞)、结束状态

##### 进程挂起：进程从内存转入外存

合理且充分地利用系统资源

> 进程在挂起状态时不占用内存空间，而是swapout 到硬盘

挂起状态：

> 1. 阻塞挂起状态(Blocked-suspend)：进程在外存并等待事件出现
> 2. 就绪挂起状态(Ready-suspend)：进程在外存，只要进入内存即可运行
>
> ---
>
> 状态转换
>
> 阻塞->阻塞挂起
>
> 就绪->就绪挂起
>
> 运行->就绪挂起
>
> 阻塞挂起->就绪挂起 ：出现在外存
>
> 就绪挂起->就绪
>
> 阻塞挂起->阻塞

##### 操作系统对进程状态的管理

**状态队列**：真的各个状态有各个状态的队列

> * 由OS来维护一组队列
>
> * 不同的状态用不同队列表示(就绪队列、阻塞队列,..)
>
> * 进程的PCB根据其状态出队入队，进程状态发送变化时，它的PCB从一个状态队列中脱离，并加入另一状态队列

### 3. 线程

##### 线程

多进程存在的问题：

> 进程间通信、共享数据
>
> 维护进程的开销大：创建进程时要分配资源，建立PCB；撤销进程时要回收资源，撤销PCB；进程切换时要保存当前进程的状态信息

对新实体提出需求：可以并发执行，可以共享地址空间

**线程的定义：** 进程中的一条执行流程

**重新认识进程：** 资源管理+线程

> 进程负责管理资源，执行状态交给线程来管理;
>
> 进程除了要管理资源，还需要一系列线程来完成执行过程



### 4. 进程间通信

### 5. 进程互斥与同步

### 6.死锁